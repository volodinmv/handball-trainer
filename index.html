<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Тренажер для гандбольного вратаря</title>

    <!-- PWA Configuration -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Goalkeeper Training">
    <link rel="apple-touch-icon" href="icon-512x512.png">
    <link rel="manifest" href="manifest.json">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">

    <style>
        body, html {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
            background-color: transparent;
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            position: fixed;
        }
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #2c3e50;
            background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.03) 50%, rgba(255, 255, 255, 0.03) 75%, transparent 75%, transparent);
            background-size: 70px 70px;
            border-radius: 2.5vmin;
        }
        #play-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            overflow: hidden;
            z-index: 1;
        }
        #settings-btn {
            position: absolute;
            top: 9.5vmin;
            right: 9.5vmin;
            z-index: 20;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5vmin;
            transition: transform 0.2s ease;
        }
        #settings-btn svg {
            width: 3.5vmin;
            height: 3.5vmin;
            fill: #b0bec5;
        }
        #settings-btn:active {
            transform: scale(0.9);
        }
        .border {
            position: absolute;
            background-color: #1f2b38;
        }
        #border-top { top: 0; left: 0; width: 100%; height: 8vmin; }
        #border-right { top: 0; right: 0; width: 8vmin; height: 100%; }
        #border-bottom { bottom: 0; left: 0; width: 100%; height: 8vmin; }
        #border-left { top: 0; left: 0; width: 8vmin; height: 100%; }
        #red-circle,
        #white-circle {
            width: 8vmin;
            height: 8vmin;
            border-radius: 50%;
            position: absolute;
            display: none;
            box-sizing: border-box;
        }
        #red-circle {
            background-color: #ff5252;
            z-index: 5;
            box-shadow: 0 0 15px rgba(255, 82, 82, 0.7);
        }
        #white-circle {
            background-color: #f0f0f0;
            border: 0.3vmin solid #455a64;
            z-index: 6;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        #controls-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            width: 90%;
            max-width: 600px;
        }
        #main-controls {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 2vmin;
            border-radius: 2vmin;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .hidden {
            display: none !important;
        }
        #mode-selector {
            margin-bottom: 2vmin;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .mode-btn,
        #start-btn,
        #stop-btn {
            cursor: pointer;
            border-radius: 1vmin;
            transition: transform 0.1s ease, background-color 0.2s ease, opacity 0.2s ease;
        }
        .mode-btn:active,
        #start-btn:active,
        #stop-btn:active,
        #close-settings-btn:active {
            transform: scale(0.98);
        }
        .mode-btn {
            padding: 1vmin 1.5vmin;
            font-size: 1.8vmin;
            font-weight: 400;
            margin: 0.5vmin;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: #eceff1;
        }
        .mode-btn.active {
            background-color: #4dd0e1;
            color: #263238;
            font-weight: 700;
        }
        .mode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #round-display {
            font-size: 3.5vmin;
            color: #b0bec5;
            margin-bottom: 2vmin;
            font-weight: 300;
        }
        #timer-display {
            font-size: 8vmin;
            font-weight: 700;
            margin-bottom: 1.5vmin;
            color: #eceff1;
        }
        #start-btn,
        #stop-btn {
            padding: 1.5vmin 3vmin;
            font-size: 2.5vmin;
            margin: 1vmin;
            border: none;
            color: #eceff1;
        }
        #start-btn { background-color: #66bb6a; }
        #stop-btn { background-color: #ef5350; }
        #settings-panel {
            background: rgba(255, 255, 255, 0.98);
            padding: 3vmin;
            border-radius: 1.5vmin;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            gap: 2vmin;
            color: #333;
        }
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .settings-row label,
        .settings-row span {
            font-size: 2.0vmin;
        }
        .settings-row label {
            white-space: nowrap;
            margin-right: 1.5vmin;
            color: #37474f;
        }
        .settings-row span {
            font-weight: bold;
            min-width: 9vmin;
            text-align: right;
            color: #000;
        }
        #close-settings-btn {
            padding: 1.5vmin;
            font-size: 2.0vmin;
            font-weight: bold;
            cursor: pointer;
            border-radius: 1vmin;
            border: none;
            background-color: #4dd0e1;
            color: #263238;
            margin-top: 1vmin;
            transition: transform 0.1s ease;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 1.5vmin;
            background: #eceff1;
            outline: none;
            border-radius: 1vmin;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 1.5vmin;
            border-radius: 1vmin;
            background: linear-gradient(90deg, #4dd0e1 0%, #80deea 100%);
        }
        input[type="range"]::-moz-range-track {
            height: 1.5vmin;
            border-radius: 1vmin;
            background: linear-gradient(90deg, #4dd0e1 0%, #80deea 100%);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -0.75vmin;
            width: 3vmin;
            height: 3vmin;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid #b0bec5;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 3vmin;
            height: 3vmin;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid #b0bec5;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        .animate-flash {
            animation: flash-in 0.3s ease-out;
        }
        @keyframes flash-in {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .pulsing {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <button id="settings-btn" title="Настройки">
            <svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
        </button>
        <div id="controls-wrapper">
            <div id="settings-panel" class="hidden">
                <button id="close-settings-btn">Сохранить и закрыть</button>
            </div>
            <div id="main-controls">
                <div id="mode-selector">
                    <button class="mode-btn active">Прямоугольник</button>
                    <button class="mode-btn">Крест</button>
                    <button class="mode-btn">Подъем</button>
                    <button class="mode-btn">Броски</button>
                </div>
                <div id="round-display"></div>
                <div id="timer-display"></div>
                <button id="start-btn">Старт</button>
                <button id="stop-btn">Стоп</button>
            </div>
        </div>
        <div id="play-area">
            <div id="border-top" class="border"></div>
            <div id="border-right" class="border"></div>
            <div id="border-bottom" class="border"></div>
            <div id="border-left" class="border"></div>
            <div id="red-circle"></div>
            <div id="white-circle"></div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameContainer = document.getElementById("game-container");
        const startBtn = document.getElementById("start-btn");
        const stopBtn = document.getElementById("stop-btn");
        const redCircle = document.getElementById("red-circle");
        const whiteCircle = document.getElementById("white-circle");
        const timerDisplay = document.getElementById("timer-display");
        const roundDisplay = document.getElementById("round-display");
        const modeButtons = document.querySelectorAll(".mode-btn");
        const settingsBtn = document.getElementById("settings-btn");
        const settingsPanel = document.getElementById("settings-panel");
        const closeSettingsBtn = document.getElementById("close-settings-btn");
        const mainControls = document.getElementById("main-controls");

        // --- Dynamic Sizing Variables ---
        let SIZE_X, SIZE_Y, CIRCLE_DIAMETER, MAX_X, MAX_Y, MID_X, MID_Y, MAX_PATH_DISTANCE, SPEED;

        // --- Configurable Settings ---
        let rectangleSpeedDuration = 4000;
        let crossInterval = 3000;
        let riseInterval = 6000;
        let throwsInterval = 3500;
        let workSeconds = 120;
        let restSeconds = 60;
        let preparationSeconds = 5;
        let totalRounds = 10;

        // --- State Variables ---
        let currentMode = "прямоугольник";
        let gameLoopTimeout, timerInterval, preparationInterval;
        let animationTimeouts = [];
        let currentWhitePos = null;
        let currentRound = 1;
        let isWorkPhase = true;
        let secondsLeft = workSeconds;

        // --- Initial Setup ---
        window.addEventListener("resize", stopGame);
        modeButtons.forEach(btn => {
            btn.addEventListener("click", () => setMode(btn.textContent.toLowerCase(), btn));
        });
        startBtn.addEventListener("click", startGame);
        stopBtn.addEventListener("click", stopGame);
        settingsBtn.addEventListener("click", openSettings);
        closeSettingsBtn.addEventListener("click", closeSettings);

        /**
         * Dynamically creates the settings panel with sliders.
         */
        function createSettingsPanel() {
            const settings = [
                { id: "work", label: "Раунд", value: workSeconds, min: 10, max: 300, step: 10, unit: "сек" },
                { id: "rest", label: "Отдых", value: restSeconds, min: 10, max: 180, step: 5, unit: "сек" },
                { id: "prep", label: "Подготовка", value: preparationSeconds, min: 3, max: 15, step: 1, unit: "сек" },
                { id: "rounds", label: "Кол-во раундов", value: totalRounds, min: 1, max: 20, step: 1, unit: "" },
                { id: "rect-speed", label: "Прямоуг. (скорость)", value: rectangleSpeedDuration / 1000, min: 2, max: 8, step: 0.5, unit: "сек" },
                { id: "cross-int", label: "Крест (интервал)", value: crossInterval / 1000, min: 2, max: 8, step: 0.5, unit: "сек" },
                { id: "rise-int", label: "Подъем (интервал)", value: riseInterval / 1000, min: 3, max: 10, step: 0.5, unit: "сек" },
                { id: "throws-int", label: "Броски (интервал)", value: throwsInterval / 1000, min: 2, max: 8, step: 0.5, unit: "сек" }
            ];
            let html = "";
            settings.forEach(s => {
                html += `<div class="settings-row"><label for="${s.id}-slider">${s.label}</label><input type="range" id="${s.id}-slider" min="${s.min}" max="${s.max}" step="${s.step}" value="${s.value}"><span id="${s.id}-value">${s.value} ${s.unit}</span></div>`;
            });
            closeSettingsBtn.insertAdjacentHTML("beforebegin", html);

            settings.forEach(s => {
                const slider = document.getElementById(`${s.id}-slider`);
                const valueSpan = document.getElementById(`${s.id}-value`);
                slider.addEventListener("input", () => { valueSpan.textContent = `${slider.value} ${s.unit}`; });
            });
        }
        createSettingsPanel();
        
        // --- UI Flow ---
        function openSettings() {
            stopGame();
            mainControls.classList.add("hidden");
            settingsPanel.classList.remove("hidden");
            settingsBtn.classList.add("hidden");
        }

        function closeSettings() {
            workSeconds = parseInt(document.getElementById("work-slider").value);
            restSeconds = parseInt(document.getElementById("rest-slider").value);
            preparationSeconds = parseInt(document.getElementById("prep-slider").value);
            totalRounds = parseInt(document.getElementById("rounds-slider").value);
            rectangleSpeedDuration = parseFloat(document.getElementById("rect-speed-slider").value) * 1000;
            crossInterval = parseFloat(document.getElementById("cross-int-slider").value) * 1000;
            riseInterval = parseFloat(document.getElementById("rise-int-slider").value) * 1000;
            throwsInterval = parseFloat(document.getElementById("throws-int-slider").value) * 1000;

            mainControls.classList.remove("hidden");
            settingsPanel.classList.add("hidden");
            settingsBtn.classList.remove("hidden");
            initializeDisplays();
        }

        // --- Core Game Logic ---
        function setMode(mode, clickedButton) {
            if (currentMode === mode) return;
            currentMode = mode;
            modeButtons.forEach(btn => btn.classList.remove("active"));
            clickedButton.classList.add("active");
            if (!startBtn.disabled) {
                stopGame();
            }
        }

        function startGame() {
            stopGame();
            redCircle.style.display = "block";
            updateDimensions();
            redCircle.style.display = "none";
            startBtn.disabled = true;
            stopBtn.disabled = false;
            modeButtons.forEach(btn => btn.disabled = true);
            settingsBtn.disabled = true; // Also disable settings button
            startPreparationCountdown();
        }

        function stopGame() {
            clearInterval(preparationInterval);
            clearTimeout(gameLoopTimeout);
            animationTimeouts.forEach(clearTimeout);
            animationTimeouts = [];
            clearInterval(timerInterval);

            redCircle.style.display = "none";
            whiteCircle.style.display = "none";
            whiteCircle.style.transition = "none";
            timerDisplay.classList.remove("pulsing");
            
            currentWhitePos = null;
            currentRound = 1;
            isWorkPhase = true;
            secondsLeft = workSeconds;

            initializeDisplays();
            startBtn.disabled = false;
            stopBtn.disabled = true;
            modeButtons.forEach(btn => btn.disabled = false);
            settingsBtn.disabled = false;
            settingsBtn.classList.remove("hidden");
        }

        function startPreparationCountdown() {
            let countdown = preparationSeconds;
            timerDisplay.style.color = "#4dd0e1";
            roundDisplay.textContent = `Раунд ${currentRound} / ${totalRounds}`;
            timerDisplay.textContent = `Старт через: ${countdown}`;
            timerDisplay.classList.add("pulsing");

            preparationInterval = setInterval(() => {
                countdown--;
                timerDisplay.textContent = `Старт через: ${countdown}`;
                if (countdown <= 0) {
                    clearInterval(preparationInterval);
                    timerDisplay.classList.remove("pulsing");
                    runActiveMode();
                    startTimer();
                }
            }, 1000);
        }

        function runActiveMode() {
            whiteCircle.style.display = "none";
            switch (currentMode) {
                case "прямоугольник": rectangleStep(); break;
                case "крест": crossStep(); break;
                case "подъем": riseStep(); break;
                case "броски": throwsStep(); break;
            }
        }

        function startTimer() {
            secondsLeft = workSeconds;
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                secondsLeft--;
                updateTimerDisplay();
                if (secondsLeft < 0) {
                    if (isWorkPhase) {
                        isWorkPhase = false;
                        secondsLeft = restSeconds;
                        redCircle.style.display = "none";
                        clearTimeout(gameLoopTimeout);
                        if (currentRound >= totalRounds) {
                            stopGame();
                            roundDisplay.textContent = "Тренировка окончена!";
                            return;
                        }
                    } else {
                        isWorkPhase = true;
                        currentRound++;
                        clearInterval(timerInterval);
                        startPreparationCountdown();
                    }
                }
            }, 1000);
        }
        
        // --- Game Modes ---
        function rectangleStep() {
            if (!isWorkPhase) return;
            if (currentWhitePos === null) {
                currentWhitePos = getRandomSpawnPoint();
                placeCircle(whiteCircle, currentWhitePos);
            }
            let redPos;
            do {
                redPos = getRandomSpawnPoint();
            } while (redPos.name === currentWhitePos.name);
            placeCircle(redCircle, redPos);
            const animationDuration = animateWhiteCircleAlongPath(currentWhitePos, redPos);
            currentWhitePos = redPos;
            gameLoopTimeout = setTimeout(() => { if (isWorkPhase) { rectangleStep(); } }, animationDuration);
        }

        function throwsStep() {
            if (!isWorkPhase) return;
            placeCircle(redCircle, getRandomSpawnPoint());
            const hideTimeout = setTimeout(() => { redCircle.style.display = "none"; }, 1500);
            animationTimeouts.push(hideTimeout);
            gameLoopTimeout = setTimeout(throwsStep, throwsInterval);
        }

        function crossStep() {
            if (!isWorkPhase) return;
            placeCircle(redCircle, getRandomSpawnPoint());
            const hideTimeout = setTimeout(() => { redCircle.style.display = "none"; }, 1500);
            animationTimeouts.push(hideTimeout);
            gameLoopTimeout = setTimeout(crossStep, crossInterval);
        }

        function riseStep() {
            if (!isWorkPhase) return;
            placeCircle(redCircle, getRandomSpawnPoint());
            const visibleDuration = riseInterval - 1000;
            const hideTimeout = setTimeout(() => { redCircle.style.display = "none"; }, visibleDuration > 500 ? visibleDuration : 500);
            animationTimeouts.push(hideTimeout);
            gameLoopTimeout = setTimeout(riseStep, riseInterval);
        }

        // --- Utility Functions ---
        function updateDimensions() {
            SIZE_X = gameContainer.offsetWidth;
            SIZE_Y = gameContainer.offsetHeight;
            CIRCLE_DIAMETER = redCircle.offsetWidth;
            MAX_X = SIZE_X - CIRCLE_DIAMETER;
            MAX_Y = SIZE_Y - CIRCLE_DIAMETER;
            MID_X = SIZE_X / 2 - CIRCLE_DIAMETER / 2;
            MID_Y = SIZE_Y / 2 - CIRCLE_DIAMETER / 2;
            MAX_PATH_DISTANCE = MAX_X + MAX_Y;
            SPEED = MAX_PATH_DISTANCE / rectangleSpeedDuration;
        }

        function getPointsForCurrentMode() {
            const allPoints = [
                { name: "topLeft", top: 0, left: 0, side: 3 },
                { name: "topRight", top: 0, left: MAX_X, side: 0 },
                { name: "bottomRight", top: MAX_Y, left: MAX_X, side: 1 },
                { name: "bottomLeft", top: MAX_Y, left: 0, side: 2 },
                { name: "midTop", top: 0, left: MID_X, side: 0 },
                { name: "midRight", top: MID_Y, left: MAX_X, side: 1 },
                { name: "midBottom", top: MAX_Y, left: MID_X, side: 2 },
                { name: "midLeft", top: MID_Y, left: 0, side: 3 }
            ];
            switch (currentMode) {
                case "крест": return allPoints.filter(p => ["midTop", "midBottom", "midLeft", "midRight"].includes(p.name));
                case "подъем": return allPoints.filter(p => ["topLeft", "midTop", "topRight"].includes(p.name));
                default: return allPoints;
            }
        }

        function getRandomSpawnPoint() {
            const points = getPointsForCurrentMode();
            return points[Math.floor(Math.random() * points.length)];
        }

        function placeCircle(circle, pos) {
            circle.style.transition = "none";
            circle.style.top = `${pos.top}px`;
            circle.style.left = `${pos.left}px`;
            circle.style.display = "block";
            if (circle.id === "red-circle") {
                circle.classList.add("animate-flash");
                circle.addEventListener("animationend", () => {
                    circle.classList.remove("animate-flash");
                }, { once: true });
            }
        }

        function animateWhiteCircleAlongPath(startPos, endPos) {
            const pathInfo = calculateShortestPath(startPos, endPos);
            const totalDistance = pathInfo.distance;
            const totalDuration = totalDistance / SPEED;
            if (totalDistance === 0) return 0;
            let cumulativeDelay = 0;
            for (let i = 0; i < pathInfo.path.length; i++) {
                const segmentEnd = pathInfo.path[i];
                const segmentStart = (i === 0) ? startPos : pathInfo.path[i - 1];
                const segmentDistance = Math.abs(segmentStart.top - segmentEnd.top) + Math.abs(segmentStart.left - segmentEnd.left);
                const segmentDuration = (segmentDistance / totalDistance) * totalDuration;
                const timeoutId = setTimeout(((end, duration) => {
                    return () => {
                        whiteCircle.style.transition = `top ${duration}ms linear, left ${duration}ms linear`;
                        whiteCircle.style.top = `${end.top}px`;
                        whiteCircle.style.left = `${end.left}px`;
                    };
                })(segmentEnd, segmentDuration), cumulativeDelay);
                animationTimeouts.push(timeoutId);
                cumulativeDelay += segmentDuration;
            }
            return totalDuration;
        }

        function calculateShortestPath(start, end) {
            if (start.top === end.top && start.left === end.left) { return { path: [], distance: 0 }; }
            const corners = [{ top: 0, left: 0 }, { top: 0, left: MAX_X }, { top: MAX_Y, left: MAX_X }, { top: MAX_Y, left: 0 }];
            const perimeterDistance = (p1, p2) => Math.abs(p1.top - p2.top) + Math.abs(p1.left - p2.left);
            if (start.side === end.side) { return { path: [end], distance: perimeterDistance(start, end) }; }
            let dist_cw = 0, path_cw = [], current_pos_cw = { ...start }, current_side_cw = start.side;
            while (true) {
                const corner_idx = (current_side_cw + 1) % 4, corner = corners[corner_idx];
                dist_cw += perimeterDistance(current_pos_cw, corner); path_cw.push(corner);
                current_pos_cw = corner; current_side_cw = corner_idx;
                if (current_side_cw === end.side) { dist_cw += perimeterDistance(current_pos_cw, end); path_cw.push(end); break; }
            }
            let dist_ccw = 0, path_ccw = [], current_pos_ccw = { ...start }, current_side_ccw = start.side;
            while (true) {
                const corner = corners[current_side_ccw];
                dist_ccw += perimeterDistance(current_pos_ccw, corner); path_ccw.push(corner);
                current_pos_ccw = corner; current_side_ccw = (current_side_ccw + 3) % 4;
                if (current_side_ccw === end.side) { dist_ccw += perimeterDistance(current_pos_ccw, end); path_ccw.push(end); break; }
            }
            return (dist_cw <= dist_ccw) ? { path: path_cw, distance: dist_cw } : { path: path_ccw, distance: dist_ccw };
        }
        
        function initializeDisplays() {
            const minutes = Math.floor(workSeconds / 60);
            const seconds = workSeconds % 60;
            timerDisplay.textContent = `${minutes}:${String(seconds).padStart(2, "0")}`;
            timerDisplay.style.color = "#eceff1";
            roundDisplay.textContent = `Раунд 1 / ${totalRounds}`;
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(secondsLeft / 60);
            const seconds = secondsLeft % 60;
            timerDisplay.textContent = `${minutes}:${String(seconds).padStart(2, "0")}`;
            roundDisplay.textContent = isWorkPhase ? `Раунд ${currentRound} / ${totalRounds}` : "Отдых";
            timerDisplay.style.color = isWorkPhase ? "#ff5252" : "#66bb6a";
        }
        
        initializeDisplays();
        stopBtn.disabled = true;
    </script>
</body>
</html>
