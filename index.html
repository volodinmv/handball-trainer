<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Тренажер для гандбольного вратаря</title>

    <!-- PWA (Progressive Web App) Configuration -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Goalkeeper Training">
    <link rel="apple-touch-icon" href="icon-512x512.png">
    <link rel="manifest" href="manifest.json">

    <style>
        body, html {
            display: flex; justify-content: center; align-items: center;
            height: 100%; width: 100%; margin: 0;
            background-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            overflow: hidden; 
            position: fixed;
        }
        #game-container {
            width: 100%; height: 100%; position: relative;
            background-color: #e9e9e9; border-radius: 2.5vmin;
        }
        #play-area {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: inherit; overflow: hidden;
            z-index: 1;
        }
        #settings-btn {
            position: absolute; top: 9.5vmin; right: 9.5vmin; z-index: 20;
            background: none; border: none; cursor: pointer; padding: 0.5vmin;
        }
        #settings-btn svg { width: 3.5vmin; height: 3.5vmin; fill: #555; }
        .border { position: absolute; background-color: rgba(128, 128, 128, 0.5); }
        #border-top { top: 0; left: 0; width: 100%; height: 8vmin; }
        #border-right { top: 0; right: 0; width: 8vmin; height: 100%; }
        #border-bottom { bottom: 0; left: 0; width: 100%; height: 8vmin; }
        #border-left { top: 0; left: 0; width: 8vmin; height: 100%; }
        #red-circle, #white-circle {
            width: 8vmin; height: 8vmin; border-radius: 50%;
            position: absolute; display: none; box-sizing: border-box;
        }
        #red-circle { background-color: red; z-index: 5; }
        #white-circle { background-color: white; border: 0.3vmin solid #ccc; z-index: 6; }
        #controls-wrapper {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 10;
            text-align: center; width: 80%;
        }
        #settings-panel {
            background: rgba(255, 255, 255, 0.95); padding: 2vmin; border-radius: 1.5vmin;
            box-shadow: 0 0 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 1.5vmin;
        }
        .settings-row { display: flex; justify-content: space-between; align-items: center; }
        .settings-row label { font-size: 1.8vmin; white-space: nowrap; margin-right: 1.5vmin;}
        .settings-row input[type="range"] { width: 100%; }
        .settings-row span { font-size: 1.8vmin; font-weight: bold; min-width: 8vmin; text-align: right; }
        #close-settings-btn {
             padding: 1vmin; font-size: 2vmin; cursor: pointer; border-radius: 1vmin;
             border: 0.2vmin solid #aaa; background-color: #fff; margin-top: 1vmin;
        }
        .hidden { display: none !important; }
        #mode-selector { 
            margin-bottom: 2vmin; display: flex; flex-wrap: wrap; justify-content: center;
        }
        .mode-btn {
            padding: 1vmin 1.5vmin; font-size: 1.8vmin; cursor: pointer;
            margin: 0.5vmin; border-radius: 1vmin; border: 0.2vmin solid #ccc;
            background-color: #f0f0f0;
        }
        .mode-btn.active { background-color: #a5d6a7; border-color: #388e3c; }
        #round-display { font-size: 3.5vmin; color: #555; margin-bottom: 2vmin; }
        #timer-display { font-size: 8vmin; font-weight: bold; margin-bottom: 1.5vmin; color: #333; }
        #start-btn, #stop-btn {
            padding: 1.5vmin 3vmin; font-size: 2.5vmin; cursor: pointer;
            margin: 1vmin; border-radius: 1.5vmin; border: 0.2vmin solid #aaa;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <button id="settings-btn" title="Настройки">
            <svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
        </button>
        <div id="controls-wrapper">
            <div id="settings-panel" class="hidden"><button id="close-settings-btn">Сохранить и закрыть</button></div>
            <div id="main-controls">
                <div id="mode-selector">
                    <button class="mode-btn active">Прямоугольник</button> <button class="mode-btn">Крест</button>
                    <button class="mode-btn">Подъем</button> <button class="mode-btn">Броски</button>
                </div>
                <div id="round-display"></div><div id="timer-display"></div>
                <button id="start-btn">Старт</button><button id="stop-btn">Стоп</button>
            </div>
        </div>
        <div id="play-area">
            <div id="border-top" class="border"></div><div id="border-right" class="border"></div>
            <div id="border-bottom" class="border"></div><div id="border-left" class="border"></div>
            <div id="red-circle"></div><div id="white-circle"></div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameContainer = document.getElementById("game-container");
        const startBtn = document.getElementById("start-btn");
        const stopBtn = document.getElementById("stop-btn");
        const redCircle = document.getElementById("red-circle");
        const whiteCircle = document.getElementById("white-circle");
        const timerDisplay = document.getElementById("timer-display");
        const roundDisplay = document.getElementById("round-display");
        const modeButtons = document.querySelectorAll(".mode-btn");
        const settingsBtn = document.getElementById("settings-btn");
        const settingsPanel = document.getElementById("settings-panel");
        const closeSettingsBtn = document.getElementById("close-settings-btn");
        const mainControls = document.getElementById("main-controls");

        // --- Dynamic Sizing Variables ---
        let SIZE_X, SIZE_Y, CIRCLE_DIAMETER, MAX_X, MAX_Y, MID_X, MID_Y, MAX_PATH_DISTANCE, SPEED;

        // --- Configurable Settings ---
        let rectangleSpeedDuration = 4000;
        let crossInterval = 3000;
        let riseInterval = 6000;
        let throwsInterval = 3500;
        let workSeconds = 120;
        let restSeconds = 60;
        let preparationSeconds = 5;
        let totalRounds = 10;

        // --- State Variables ---
        let currentMode = "прямоугольник";
        let gameLoopTimeout, timerInterval, preparationInterval;
        let animationTimeouts = [];
        let currentWhitePos = null;
        let currentRound = 1;
        let isWorkPhase = true;
        let secondsLeft = workSeconds;

        // --- Initial Setup ---
        window.addEventListener("resize", stopGame);
        modeButtons.forEach(btn => {
            btn.addEventListener("click", () => setMode(btn.textContent.toLowerCase(), btn));
        });
        startBtn.addEventListener("click", startGame);
        stopBtn.addEventListener("click", stopGame);
        settingsBtn.addEventListener("click", openSettings);
        closeSettingsBtn.addEventListener("click", closeSettings);

        /**
         * Dynamically creates the settings panel with sliders.
         */
        function createSettingsPanel() {
            const settings = [
                { id: "work", label: "Раунд", value: workSeconds, min: 10, max: 300, step: 10, unit: "сек" },
                { id: "rest", label: "Отдых", value: restSeconds, min: 10, max: 180, step: 5, unit: "сек" },
                { id: "prep", label: "Подготовка", value: preparationSeconds, min: 3, max: 15, step: 1, unit: "сек" },
                { id: "rounds", label: "Кол-во раундов", value: totalRounds, min: 1, max: 20, step: 1, unit: "" },
                { id: "rect-speed", label: "Прямоуг. (скорость)", value: rectangleSpeedDuration / 1000, min: 2, max: 8, step: 0.5, unit: "сек" },
                { id: "cross-int", label: "Крест (интервал)", value: crossInterval / 1000, min: 2, max: 8, step: 0.5, unit: "сек" },
                { id: "rise-int", label: "Подъем (интервал)", value: riseInterval / 1000, min: 3, max: 10, step: 0.5, unit: "сек" },
                { id: "throws-int", label: "Броски (интервал)", value: throwsInterval / 1000, min: 2, max: 8, step: 0.5, unit: "сек" }
            ];
            let html = "";
            settings.forEach(s => {
                html += `<div class="settings-row"><label for="${s.id}-slider">${s.label}</label><input type="range" id="${s.id}-slider" min="${s.min}" max="${s.max}" step="${s.step}" value="${s.value}"><span id="${s.id}-value">${s.value} ${s.unit}</span></div>`;
            });
            closeSettingsBtn.insertAdjacentHTML("beforebegin", html);

            settings.forEach(s => {
                const slider = document.getElementById(`${s.id}-slider`);
                const valueSpan = document.getElementById(`${s.id}-value`);
                slider.addEventListener("input", () => { valueSpan.textContent = `${slider.value} ${s.unit}`; });
            });
        }
        createSettingsPanel();
        
        // --- UI Flow ---
        function openSettings() {
            stopGame();
            mainControls.classList.add("hidden");
            settingsPanel.classList.remove("hidden");
            settingsBtn.classList.add("hidden");
        }

        function closeSettings() {
            workSeconds = parseInt(document.getElementById("work-slider").value);
            restSeconds = parseInt(document.getElementById("rest-slider").value);
            preparationSeconds = parseInt(document.getElementById("prep-slider").value);
            totalRounds = parseInt(document.getElementById("rounds-slider").value);
            rectangleSpeedDuration = parseFloat(document.getElementById("rect-speed-slider").value) * 1000;
            crossInterval = parseFloat(document.getElementById("cross-int-slider").value) * 1000;
            riseInterval = parseFloat(document.getElementById("rise-int-slider").value) * 1000;
            throwsInterval = parseFloat(document.getElementById("throws-int-slider").value) * 1000;

            mainControls.classList.remove("hidden");
            settingsPanel.classList.add("hidden");
            settingsBtn.classList.remove("hidden");
            initializeDisplays();
        }

        // --- Core Game Logic ---
        function setMode(mode, clickedButton) {
            if (currentMode === mode) return;
            currentMode = mode;
            modeButtons.forEach(btn => btn.classList.remove("active"));
            clickedButton.classList.add("active");
            if (!startBtn.disabled) {
                stopGame();
            }
        }

        function startGame() {
            stopGame();
            redCircle.style.display = "block";
            updateDimensions();
            redCircle.style.display = "none";
            startBtn.disabled = true;
            stopBtn.disabled = false;
            startPreparationCountdown();
        }

        function stopGame() {
            clearInterval(preparationInterval);
            clearTimeout(gameLoopTimeout);
            animationTimeouts.forEach(clearTimeout);
            animationTimeouts = [];
            clearInterval(timerInterval);

            redCircle.style.display = "none";
            whiteCircle.style.display = "none";
            whiteCircle.style.transition = "none";
            currentWhitePos = null;
            currentRound = 1;
            isWorkPhase = true;
            secondsLeft = workSeconds;

            initializeDisplays();
            startBtn.disabled = false;
            stopBtn.disabled = true;
            settingsBtn.classList.remove("hidden");
        }

        function startPreparationCountdown() {
            let countdown = preparationSeconds;
            timerDisplay.style.color = "#337ab7";
            roundDisplay.textContent = `Раунд ${currentRound} / ${totalRounds}`;
            timerDisplay.textContent = `Старт через: ${countdown}`;

            preparationInterval = setInterval(() => {
                countdown--;
                timerDisplay.textContent = `Старт через: ${countdown}`;
                if (countdown <= 0) {
                    clearInterval(preparationInterval);
                    runActiveMode();
                    startTimer();
                }
            }, 1000);
        }

        function runActiveMode() {
            whiteCircle.style.display = "none";
            switch (currentMode) {
                case "прямоугольник": rectangleStep(); break;
                case "крест": crossStep(); break;
                case "подъем": riseStep(); break;
                case "броски": throwsStep(); break;
            }
        }

        function startTimer() {
            secondsLeft = workSeconds;
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                secondsLeft--;
                updateTimerDisplay();
                if (secondsLeft < 0) {
                    if (isWorkPhase) {
                        isWorkPhase = false;
                        secondsLeft = restSeconds;
                        redCircle.style.display = "none";
                        clearTimeout(gameLoopTimeout);
                        if (currentRound >= totalRounds) {
                            stopGame();
                            roundDisplay.textContent = "Тренировка окончена!";
                            return;
                        }
                    } else {
                        isWorkPhase = true;
                        currentRound++;
                        clearInterval(timerInterval);
                        startPreparationCountdown();
                    }
                }
            }, 1000);
        }
        
        // --- Game Modes ---
        function rectangleStep() {
            if (!isWorkPhase) return;
            if (currentWhitePos === null) {
                currentWhitePos = getRandomSpawnPoint();
                placeCircle(whiteCircle, currentWhitePos);
            }
            let redPos;
            do {
                redPos = getRandomSpawnPoint();
            } while (redPos.name === currentWhitePos.name);
            placeCircle(redCircle, redPos);
            const animationDuration = animateWhiteCircleAlongPath(currentWhitePos, redPos);
            currentWhitePos = redPos;
            gameLoopTimeout = setTimeout(() => { if (isWorkPhase) { rectangleStep(); } }, animationDuration);
        }

        function throwsStep() {
            if (!isWorkPhase) return;
            placeCircle(redCircle, getRandomSpawnPoint());
            const hideTimeout = setTimeout(() => { redCircle.style.display = "none"; }, 1500);
            animationTimeouts.push(hideTimeout);
            gameLoopTimeout = setTimeout(throwsStep, throwsInterval);
        }

        function crossStep() {
            if (!isWorkPhase) return;
            placeCircle(redCircle, getRandomSpawnPoint());
            const hideTimeout = setTimeout(() => { redCircle.style.display = "none"; }, 1500);
            animationTimeouts.push(hideTimeout);
            gameLoopTimeout = setTimeout(crossStep, crossInterval);
        }

        function riseStep() {
            if (!isWorkPhase) return;
            placeCircle(redCircle, getRandomSpawnPoint());
            const visibleDuration = riseInterval - 1000;
            const hideTimeout = setTimeout(() => { redCircle.style.display = "none"; }, visibleDuration > 500 ? visibleDuration : 500);
            animationTimeouts.push(hideTimeout);
            gameLoopTimeout = setTimeout(riseStep, riseInterval);
        }

        // --- Utility Functions ---
        function updateDimensions() {
            SIZE_X = gameContainer.offsetWidth;
            SIZE_Y = gameContainer.offsetHeight;
            CIRCLE_DIAMETER = redCircle.offsetWidth;
            MAX_X = SIZE_X - CIRCLE_DIAMETER;
            MAX_Y = SIZE_Y - CIRCLE_DIAMETER;
            MID_X = SIZE_X / 2 - CIRCLE_DIAMETER / 2;
            MID_Y = SIZE_Y / 2 - CIRCLE_DIAMETER / 2;
            MAX_PATH_DISTANCE = MAX_X + MAX_Y;
            SPEED = MAX_PATH_DISTANCE / rectangleSpeedDuration;
        }

        function getPointsForCurrentMode() {
            const allPoints = [
                { name: "topLeft", top: 0, left: 0, side: 3 },
                { name: "topRight", top: 0, left: MAX_X, side: 0 },
                { name: "bottomRight", top: MAX_Y, left: MAX_X, side: 1 },
                { name: "bottomLeft", top: MAX_Y, left: 0, side: 2 },
                { name: "midTop", top: 0, left: MID_X, side: 0 },
                { name: "midRight", top: MID_Y, left: MAX_X, side: 1 },
                { name: "midBottom", top: MAX_Y, left: MID_X, side: 2 },
                { name: "midLeft", top: MID_Y, left: 0, side: 3 }
            ];
            switch (currentMode) {
                case "крест": return allPoints.filter(p => ["midTop", "midBottom", "midLeft", "midRight"].includes(p.name));
                case "подъем": return allPoints.filter(p => ["topLeft", "midTop", "topRight"].includes(p.name));
                default: return allPoints;
            }
        }

        function getRandomSpawnPoint() {
            const points = getPointsForCurrentMode();
            return points[Math.floor(Math.random() * points.length)];
        }

        function placeCircle(circle, pos) {
            circle.style.transition = "none";
            circle.style.top = `${pos.top}px`;
            circle.style.left = `${pos.left}px`;
            circle.style.display = "block";
        }

        function animateWhiteCircleAlongPath(startPos, endPos) {
            const pathInfo = calculateShortestPath(startPos, endPos);
            const totalDistance = pathInfo.distance;
            const totalDuration = totalDistance / SPEED;
            if (totalDistance === 0) return 0;
            let cumulativeDelay = 0;
            for (let i = 0; i < pathInfo.path.length; i++) {
                const segmentEnd = pathInfo.path[i];
                const segmentStart = (i === 0) ? startPos : pathInfo.path[i - 1];
                const segmentDistance = Math.abs(segmentStart.top - segmentEnd.top) + Math.abs(segmentStart.left - segmentEnd.left);
                const segmentDuration = (segmentDistance / totalDistance) * totalDuration;
                const timeoutId = setTimeout(((end, duration) => {
                    return () => {
                        whiteCircle.style.transition = `top ${duration}ms linear, left ${duration}ms linear`;
                        whiteCircle.style.top = `${end.top}px`;
                        whiteCircle.style.left = `${end.left}px`;
                    };
                })(segmentEnd, segmentDuration), cumulativeDelay);
                animationTimeouts.push(timeoutId);
                cumulativeDelay += segmentDuration;
            }
            return totalDuration;
        }

        function calculateShortestPath(start, end) {
            if (start.top === end.top && start.left === end.left) { return { path: [], distance: 0 }; }
            const corners = [{ top: 0, left: 0 }, { top: 0, left: MAX_X }, { top: MAX_Y, left: MAX_X }, { top: MAX_Y, left: 0 }];
            const perimeterDistance = (p1, p2) => Math.abs(p1.top - p2.top) + Math.abs(p1.left - p2.left);
            if (start.side === end.side) { return { path: [end], distance: perimeterDistance(start, end) }; }
            let dist_cw = 0, path_cw = [], current_pos_cw = { ...start }, current_side_cw = start.side;
            while (true) {
                const corner_idx = (current_side_cw + 1) % 4, corner = corners[corner_idx];
                dist_cw += perimeterDistance(current_pos_cw, corner); path_cw.push(corner);
                current_pos_cw = corner; current_side_cw = corner_idx;
                if (current_side_cw === end.side) { dist_cw += perimeterDistance(current_pos_cw, end); path_cw.push(end); break; }
            }
            let dist_ccw = 0, path_ccw = [], current_pos_ccw = { ...start }, current_side_ccw = start.side;
            while (true) {
                const corner = corners[current_side_ccw];
                dist_ccw += perimeterDistance(current_pos_ccw, corner); path_ccw.push(corner);
                current_pos_ccw = corner; current_side_ccw = (current_side_ccw + 3) % 4;
                if (current_side_ccw === end.side) { dist_ccw += perimeterDistance(current_pos_ccw, end); path_ccw.push(end); break; }
            }
            return (dist_cw <= dist_ccw) ? { path: path_cw, distance: dist_cw } : { path: path_ccw, distance: dist_ccw };
        }
        
        function initializeDisplays() {
            const minutes = Math.floor(workSeconds / 60);
            const seconds = workSeconds % 60;
            timerDisplay.textContent = `${minutes}:${String(seconds).padStart(2, "0")}`;
            timerDisplay.style.color = "#333";
            roundDisplay.textContent = `Раунд 1 / ${totalRounds}`;
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(secondsLeft / 60);
            const seconds = secondsLeft % 60;
            timerDisplay.textContent = `${minutes}:${String(seconds).padStart(2, "0")}`;
            roundDisplay.textContent = isWorkPhase ? `Раунд ${currentRound} / ${totalRounds}` : "Отдых";
            timerDisplay.style.color = isWorkPhase ? "red" : "green";
        }
        
        initializeDisplays();
        stopBtn.disabled = true;
    </script>
</body>
</html>
